python3 -m venv venv
Select correct virtual environment for interpreter
source venv/bin/activate

pip3 install "fastapi[all]"

# Add a __init__.py file inside app folder

# When main.py is inside app folder
uvicorn app.main:app --reload

pip3 install psycopg2-binary
pip3 install sqlalchemy

# zsh needs quote characters to work with the [] symbols
pip3 install 'passlib[bcrypt]'

pip3 install 'python-jose[cryptography]'


# When trying to login with Postman via the login method in auth.py use form-data instead of raw


# When trying to access something via Postman that needs authorization with tokens, login with method, get token
  and paste that token under the Headers section like the following ex. :
     Key = Authorization 
     Value = Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwiZXhwIjoxNjM3OTY5NDc0fQ.3hYg9V_B73pnekbrHJ2SUHI06eGst1C-j3wHg8jarzs


# In Postman, in order to not keep manually generating JWTs when they expire and pasting them into 
  the other paths, put this under "Tests" in the login path:
     pm.environment.set("JWT", pm.response.json().access_token);
  Click "Send" afterwards.

  Then anywhere where the token needs to be inserted, enter {{JWT}} in its place if that
  is the name of the variable


# For Alembic
pip3 install alembic
alembic init alembic
alembic revision -m "create posts table" 
alembic upgrade <revision ID>       # revision ID = ae9cf3387f8e 
alembic revision -m "add content column to posts table"
alembic heads    # Latest revision
alembic current
alembic upgrade head           # Upgrade to latest revision
alembic revision --autogenerate -m "auto-vote"

# Usually run 
    alembic revision -m <message>    OR    alembic revision --autogenerate -m <message>
then try 
    alembic upgrade head
 



# Before git init, have 
    __pycache__ 
    venv/  
    .env 
in .gitignore

# Like a npm install for Python
pip3 freeze > requirements.txt     # Tells user what to install
pip3 install -r requirements.txt   # Installs all necessary packages if cloned, etc.

# To make default branch on fresh git install 
    git config --global init.defaultBranch main

---------------------------------------------

*** Everything up to running postgres command on get route ***
{
    from fastapi import FastAPI, Response, status, HTTPException
    from fastapi.params import Body
    from pydantic import BaseModel
    from typing import Optional
    from random import randrange
    import psycopg2
    from psycopg2.extras import RealDictCursor
    import time


    app = FastAPI()


    class Post(BaseModel):
        title: str
        content: str
        published: bool = True

    while True:
        try:
            conn = psycopg2.connect(host='localhost', database='fast-api', user='postgres', password='password123$!', cursor_factory=RealDictCursor)
            cursor = conn.cursor()
            print('Database connection was successfull')
            break
        except Exception as error:
            print('Connecting to database failed')
            print('Error: ', error)
            time.sleep(2)


    my_posts = [
        {
            "title": "title of post 1",
            "content": "content of post 1",
            "id": 1
        },
        {
            "title": "title of post 2",
            "content": "content of post 2",
            "id": 2
        }
    ]


    def find_post(id):
        for p in my_posts:
            if p["id"] == id:
                return p


    def find_index_post(id):
        for i, p in enumerate(my_posts):
            if p['id'] == id:
                return i


    @app.get("/")
    async def root():
        return {"message": "Welcome to my API"}


    @app.get("/posts")
    def get_posts():
        cursor.execute(""" SELECT * FROM posts """)
        posts = cursor.fetchall()
        print(posts)
        return {"data": my_posts}


    @app.post("/posts", status_code=status.HTTP_201_CREATED)
    def create_posts(post: Post):
        post_dict = post.dict()
        post_dict['id'] = randrange(0, 1000000)
        my_posts.append(post_dict)
        return {"data": post_dict}


    @app.get('/posts/{id}')
    def get_post(id: int):
        # print(id)
        post = find_post(id)
        if not post:
            raise HTTPException(status_code =status.HTTP_404_NOT_FOUND, detail=f"post with id {id} was not found")
        return {"post_detail": post}


    @app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
    def delete_post(id: int):
        index = find_index_post(id)
    
        if index == None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"post with id: {id} does not exist")
    
        my_posts.pop(index)
        return Response(status_code=status.HTTP_204_NO_CONTENT)


    @app.put('/posts/{id}')
    def update_post(id: int, post: Post):
        index = find_index_post(id)
    
        if index == None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"post with id: {id} does not exist")
    
        post_dict = post.dict()
        post_dict['id'] = id
        my_posts[index] = post_dict
        return {'data': post_dict}
}
*** END ***

*** Everything before ORM implementation ***
{
    from fastapi import FastAPI, Response, status, HTTPException
    from fastapi.params import Body
    from pydantic import BaseModel
    from typing import Optional
    from random import randrange
    import psycopg2
    from psycopg2.extras import RealDictCursor
    import time


    app = FastAPI()


    class Post(BaseModel):
        title: str
        content: str
        published: bool = True

    while True:
        try:
            conn = psycopg2.connect(host='localhost', database='fast-api', user='postgres', password='password123$!', cursor_factory=RealDictCursor)
            cursor = conn.cursor()
            print('Database connection was successfull')
            break
        except Exception as error:
            print('Connecting to database failed')
            print('Error: ', error)
            time.sleep(2)


    my_posts = [
        {
            "title": "title of post 1",
            "content": "content of post 1",
            "id": 1
        },
        {
            "title": "title of post 2",
            "content": "content of post 2",
            "id": 2
        }
    ]


    def find_post(id):
        for p in my_posts:
            if p["id"] == id:
                return p


    def find_index_post(id):
        for i, p in enumerate(my_posts):
            if p['id'] == id:
                return i


    @app.get("/")
    async def root():
        return {"message": "Welcome to my API"}


    @app.get("/posts")
    def get_posts():
        cursor.execute(""" SELECT * FROM posts """)
        posts = cursor.fetchall()
        return {"data": posts}


    @app.post("/posts", status_code=status.HTTP_201_CREATED)
    def create_posts(post: Post):
        cursor.execute(""" INSERT INTO posts (title, content, published) VALUES (%s, %s, %s) RETURNING * """, (post.title, post.content, post.published))
        new_post = cursor.fetchone()
        conn.commit()
        return {"data": new_post}


    @app.get('/posts/{id}')
    def get_post(id: int):
        cursor.execute(""" SELECT * FROM posts WHERE id = %s """, (str(id),))
        post = cursor.fetchone()
    
        if not post:
            raise HTTPException(status_code =status.HTTP_404_NOT_FOUND, detail=f"post with id {id} was not found")
        return {"post_detail": post}


    @app.delete("/posts/{id}", status_code=status.HTTP_204_NO_CONTENT)
    def delete_post(id: int):
        cursor.execute("""DELETE FROM posts WHERE id = %s returning *""", (str(id),))
        deleted_post = cursor.fetchone()
        conn.commit()
    
        if deleted_post == None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"post with id: {id} does not exist")
    
        return Response(status_code=status.HTTP_204_NO_CONTENT)


    @app.put('/posts/{id}')
    def update_post(id: int, post: Post):
        cursor.execute("""UPDATE posts SET title = %s, content = %s, published=%s WHERE id = %s RETURNING * """, (post.title, post.content, post.published, str(id)))
        updated_post = cursor.fetchone()
        conn.commit()
        
        if updated_post == None:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"post with id: {id} does not exist")
    
        return {'data': updated_post}
}
*** END ***